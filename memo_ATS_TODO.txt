
640X400(現画面)
	frame(0,x,y)
640X400(fix, undo)
	frame(1,x,y)

320X200(push0,pop0)
	scrntoems((2+1)*animofset+1)
frame320(0) → ems
	frame320toems(0,(2+1)*animofset+1)

procedure pushscreen, popscreen
	ライトテーブルがオンの場合の scrntoems((2+1)*animofset+1)


frame320point(0,x,y)
	ライトテーブルがオンの場合の描画画面

カットブラシの保存フレーム
	cutbrushpage := (2+1)*animofset+3
	frame320toems(1,cutbrushpage)

ブラシ, アニメブラシ の場合の参照フレーム
	frame320point(1,x,y)

ブラシfig, アニメブラシfig の場合の参照フレーム
	blbrushpoint(x,y) →  frame320point(1,x,y)

paintルーチンでの作業フレーム
	paintframe(x,y)  (paintframe は、frame320 なので 640X400 に対応不可)



■アニムフレーム数を変えた場合、ブラシや退避フレームがズレる
	→ setup2 で、EMSフレームの割り当てを animofset*3 以上で確保していなかった

□scrntoframe320ルーチン作成が必要か？(fix0, undo0)
	(640X400(fix, undo) の場合は、実vramにマッピングされたframe間copy)
	frame320toframe は、frame1 しか対応していない(実vramは、frame0)
		GRAD2.PAS に重複ルーチン有

--------------------------------------------------------------------------


■Screen 640X400 の画像を保存するルーチンが無い
	→ AGRAPH2.PAS の iffsave ルーチンに、640X400画像モードを追加
	そのルーチンを呼び出している uemsop.pas, picop.pas を変更
	(640X400画像の色ソートは、picop.pas の compress1/n メニューの中)

■テンポラリ画像ファイルへの入出力 >Tmp, <Tmp
	→ PIC\TMP.IFF に上書き保存

□MAG形式画像のLoad
	→ MPS のサンプルコードを実装してみたが、buffer=64K 以上のファイルでエラー
	iffload のように逐次blockread のメドがつくまで保留



■\PST からの include を廃止、sysbrush.inc を親ディレクトリにコピー

□\PST に、リソース類を移動。(brush.ptn, tone.ptn, ... )

■animframe0,1 の連動をデフォルトではOFFに変更


■[複]→[鏡]、[対]→[源]、[ M]→[⇒] に変更
    筆|色|覆|[]|B]|A]|複|対|効| M|  ↓
    筆|色|[]/[B/[A|源/効/Ｍ|鏡|⇒|
■Tile → 網 として、階層が上のメニューを 筆|色|網 に変更

■[筆] ブラシ定義ファイルの切り替え
	const  patternfilename : string[12] = 'BRUSH.PTN';  → var
               tonefilename    : string[12] = 'TONE.PTN';   → var

■[Ｍ] 裏画面マスクの動作が逆では？(現状 0 がマスクされる)
	→ 逆にした。(マスク反転して転送では手間が増えるため)
■裏画面マスク-デジタルでの挙動が変。maxcolorのみがマスク
	→ プログラムミスを修正した(sysbrush.inc)
■裏画面マスク-アナログでの挙動が変。[比較明]が効かない、マスク対象でも描画される
	→ プログラムミスを修正した(sysbrush.inc)

■/Ｍ| メニュー名称＆並びの整理
		Sp|Cr|Iv|bc|bD|bA|Ok| ?   ↓
		sp/反/無|bA/bD/無|ok| ?
□/Ｍ| 裏画面マスクに、|bX| を追加。maskに応じてオーバーレイ、アンダーレイの切り替え
	□メニューに空きが無いので、|ok| を削除？
□/Ｍ| 裏画面マスクをZバッファとみなして重ね合わせをコントロール



■2色トーンパターン対象元の場合、bgbolorが0の場合画面の色を保護
	→ bgcolor=0 で、c=tempc とした(簡易解決)
	□Brshルーチンのように、独立して処理すべき？
■デフォルトのbgcolor=0
■2色トーンパターンのリバース
	□現リバースアイテムは、トーン定義ファイルの切り替えに使って、リバースはキーで
□2色トーンパターンのグラデパターン間ローテート


□/複| メニュー名称＆並びの整理
	 OFF |Cycle/     |Place|Centr|X -fp|Y -fp|XY-fp| Tile| 千鳥| 市松|x分割|y分割
	OFF :| 点対(     /中心)|x-fp /y-fp /xy-fp| Tile/x千鳥/y千鳥/ 市松(x    /y    ) 
■[中心]選択で、[座標中心に復帰]を兼ねる
	→ positionchenge ルーチンを追加した



■対象元[表画] 機能確認  point(x,y) と point(x,y) の効果となり、意味がない？
	→ 削除。表画の[inc],[dec]は、一旦コピーした先を参照先として行う
■/対| メニュー名称＆並びの整理
	色  |表画|裏画|Undo|Tile|Dist|Grad|Patn|PtCy|Brsh|Bfig|AniB|Afig    ↓
	色  /網  |裏画/Undo/下画/転写|Grad| [] | []c| [B | [Bf| [A | [Af
	sbinktype = (sbfill,sbmae,sbura,sbtemp,sbtile,sbsita,sbgrad,
	             sbpatn,sbpacy,sbbrush,sbbrushfig,sbanim,sbanimfig)     ↓
	sbinktype = (sbfill,sbtile,sbura,sbtemp,sbsita,sbdist,sbgrad,
	             sbpatn,sbpacy,sbbrush,sbbrushfig,sbanim,sbanimfig)
■[Dist] を [下画],[転写] に分ける。
	→ [Dist] 選択は、直接参照先を指定するようにする
	■[下画],[転写] で、参照元・参照先の二つのカーソルを表示


□ラインオプションで、N_Total の分割点ごとにエフェクトルーチンを呼べるようにする
	パラメータ: 座標、方向ベクトル(角度)、筆の大きさ
		□先に、カットブラシでの sbbrushfig ルーチンを実装したほうが楽かも
			□アニムブラシでの sbanimfig ルーチンを実装
			□[C_inc],[C_dec]モード時に、ブラシの拡大縮小
	□トゲを交互に
	□ツルマキの発生
	□二分木の再帰図形



○多角形
■di=0 の次のパラメータは何？
	→ 回転角だった
	■[正多],[星] で、回転角をマウス選択(or 数値入力)できるようにする
	→ 数値入力のまま(ツール・モーフィングのため)
□di=0 のパラメータは、右回り 左回り のブーリアン型にして誤入力を防ぐべきか？
□[自由]の追加
□di=0 のパラメータを、[自由],[正多],[星] にも適用
	→ 数値入力として、ツールモーフに対応させる
■バラの選択時、外円径を選択すると、外円径が0になるバグ
	→ select の until → repeat 後に offbutton を追加
	■いつのまにか外円径が0になるバグ再び
	→ 外円径を write でテキスト表示させると、おさまったようにみえる
■星型の[C_dec]モード時、頂点に向かって減衰するようにしたい
	→ 線分の始点と終点を入れ替える方法にした(パスとして使う場合には不具合)
■星型の[C_inc]モードを追加
□対数螺旋の追加
□ポリゴン座標列のファイルへの保存・読み込み・編集

○多角形ペイント
□[自由] 、[正多]、[星]、メニューの追加 


□[円],[楕円] で、右回り 左回り のパラメータを追加、
□[円],[楕円] で、回転角をマウス選択(or 数値入力)できるようにする
□[円塗],[楕円塗] で、回転角をマウス選択(or 数値入力)できるようにする
	□現在共有しているselectlinestyleを、line,curve,box と分ける必要がある


□筆形状カットブラシ[] → パターンブラシ[] に変更
	(筆ルーチンを利用したカットだと15X15になっていてタイルペイントがいまいち)
○パターンブラシ[] 選択時
	□全角文字選択の削除
	□2色タイルパターンの選択を追加(IFFファイル)
	□3色タイルパターン生成の選択を追加
	□パターンの選択を追加(IFFファイル)
	□パターンの選択(IFFファイル)で、アニメパターンへの対応
	□パターンの編集
	□ファイルから選択した文字列をアニメパターンとする
パターンブラシ[Patn] 選択時
	□[PtCy] を廃止して、[Patn] で選択できるようにする



□グラデ塗りに、ベベルパターン(外形線より一定のグラデ)の追加
□グラデ塗りに、cyclic 循環数の設定



○カットブラシ[B
□選択時の[文字列]の削除?
	□ファイルから選択できるようにする
□現状、ems にコピーされてるブラシの数を１から複数選択可能にする
	DeluxePaint のように、スペアブラシで十分？
	□ブラシ→スペアブラシ間で変形アニムブラシ
□通常、not0、に追加「fix and Overlay/Underlay」
	裏画面マスクに応じて、自動fixscreenした画像とブラシをOverlay/Underlay切替
□対象元[Bfig] の場合、line系では、ブラシを進行ベクトルに向けて回転変形させる
□ブラシ変形モードを追加(x_flip,y_flip,x_bend,y-bend,拡大縮小回転,四隅自由変形,...)
	変形したブラシに新たなバッファを割当てるとバッファオーバーの可能性有
	→ 変形フラグと変形座標のみで、いちいち毎度に変形させる。
	□ブラシ変形をアニムブラシに変換

□カットブラシ[B を、[回転・拡大・縮小・アニメ]に対応させるまでの暫定策を検討
	(回転だけなら、すでに渦潮が [utrans2 (かなり複雑なオプション)] にある)
	→ [回転・拡大・縮小・アニメ] に特化した別ルーチンを [utrans2] に用意



○アニメカットブラシ[A 選択時
□アニメブラシのカットフレーム数を選択可能にする



□ライトテーブル back2のフレーム番号を固定に切り替え可能に




■キー入力の再検討  PGLOBAL.PAS animscreenルーチンの変更
	AutoBr  ブラシを置くたびにフレ−ムを進める	key[a]トグル  key[A]OFF
	消去    画面を選択した色で消去します            key[0]0クリア Key[C]320クリア
	ライトテーブルon/off    key[t]トグル  key[T]OFF
	現座標を表示            key[@]トグル
	現在位置を記憶          key[p]
        記憶した位置に移動      key[P]
        前回描画の開始点に移動  key[(]
        前回描画の終了点に移動  key[)]
        画面中心に移動          key[=]
	グリッドを有効に        key[g]トグル  key[G]メニュー
		([j]で、裏画面のタイルチップを[g]でパターンブラシに拾う準備)
		■16X16, 32X32 のタイルに合わせて切り替える仕組みを設ける
			→ temp_gridx, temp_gridy で、前回の選択を記憶する
		■あらためて動作確認すると、グリッドがズレる 
			→ fmmouse.pas:  x-(x mod gridx),y-(y mod gridy) に変更
■カーソルキーで、色・タイルパターン・筆の切り替え
	■エミュのマウスホイールを↑↓に割り当てられるのを考慮して検討
	key[→] max_number	key[←] min_number
	key[↑] inc_number	key[↓] dec_number
	key[PageUp]  Over	key[PageDown]  Under	インジケーターを付けた
	key[[]  inc burush_num  key[]]  dec burush_num
		BRUSH.PTN の0-7の順番を逆にした
	key[i] 色をスポイトで   key[I] 色選択
	key[{] 筆選択           key[}] タイル選択
		□selectbrush に対する systemparam.currentbrush の変数スコープが？
■ルーペでのキー入力変更
	key[↑] 画面を上に移動	key[↓] 画面を下に移動
	key[→] 画面を右に移動	key[←] 画面を左に移動
        Key[{]  色番号を１増	Key[}]  色番号を１減
        Key[[]  色スポイト      Key[]]  色pset
        Key[PU] 色pset +1       Key[PD] 色pset -1


○Usr1
■メニュー名称＆並びの整理
	→  水引 /ボケ /砂目 |滲み |cycle|流線 /流蔓 |
□ブラシ形状に依存している筆ルーチンに、ブラシ選択メニューを追加

□cycle で、[Ctdec=(全長)],[Ctinc=(全長)],[全長]

■Hair で、[dec] の名称を [全長] として、現在値も表示
■BRUSH.PTN の0-7の順番を逆にしたことでの不具合を修正
	■SYSBRUSH.INC での該当ルーチンも修正
□Hair で、total ごとに蔓を巻かせる
□Hair と Usr2 rope を統合？


○Usr2
■rope 描画モードの Over と Under を切り替え(描画途中でも、キーで切り替え可能に)
	→ 結局、Under の場合は、fixscreen を参照するようにした
	自動fixscreenをやめて、手動fixscreenにした(任意の時点でコントロールできる)
	autoscreen がキーバッファをクリアするため、同等のルーチンを組み込んだ
	→ 拡張キーは、一度readkeyで#0の場合、再度readkeyで読み取る(pageup,pagedown)
	■カーソルキーで、色変更。] [キーで、筆変更
	□特筆の種類に合わせて、拡張キー処理内容を替えられるルーチンに変更
□ねじりを二本、三本と追加 
□スクリプト(pset,line,curve,...)をロードして、自動描画に対応
□スクリプト内の座標を変形させてのアニメーション

□一定間隔で、枝を発生するツタ

□ビットマップストローク・ブラシの検討

□画面0を paintframe に転送して、ペイント・ルーチンを呼ぶ
	□GRAD2.pas との住み分け
□画面0を スキャンラインした結果を paintframe に書き込み、ペイント・ルーチンを呼ぶ


-----------------------------------------------------------------------------


□1Dセル・オートマタの改良
	□横書き対応。分割数で繰り返し、スクルールアニメに対応
		□分割線で、円柱グラデパターンと合成
	□対数螺旋座標変形で、スクロールアニメ
		極座標変形で、スクロールアニメを参照して検討すること



□線形変換ルーチンを再検討 (UTRANS → s\vect.pas)




□UMAPPING.PAS に追加。TimeDisplace 時間置き換え After Effectsのエフェクトを参考




■かごめルーチンを検討 (upatgen2 → s\pt5.pas)
	参照先のアニメ・ナンバーの優先度を 0>1>2>0>.... として、合成
	■優先順序を選択可能に
	□サンプルパターンで、色がズレていく？
	■アニメフレーム 1,2,3 から参照先画像位置にコピーする機能をつける
		paintで、ライトテーブルをオンにすると、確認しながら描画できる
	■アニメフレーム 1,2,3,4 から合成。(1,2,3だとトータルで奇数フレームのみ有効)
		この場合、優先順序は選択できない
□かごめルーチンをペイントシステムにも導入すべきか？
	■Totalstep が多い場合、アニメ・フレームを進めず総フレーム数に収めるモード
		変数dotstepを導入。(i mod dotstep)=0 でないとautoscreenさせない
		→ とりあえずは、円描画ルーチンのみに適用した
		→ line, 曲線, 楕円ルーチンにも適用した
		line, 曲線のループ変数: 0 → n-1 :(i+1) mod dotstep
		円,   楕円のループ変数: 1 → n   :i mod dotstep
	□参照先をアニメフレームに、優先度を 1>2>3>..>最終フレーム>1 として合成
		とりあえずは 1>2>3>1 の簡易バージョン

□複眼ルーチンを再検討 (ufilter → s\fuku.pas)
	六角形タイルパターンをディストーションフィルタとして元画像を変形させる
		■現状の s\fuku.pas は、s\slit.pas に変更
			→ 結局、削除した
	■まず、わかりにくい現状 [umapping] の置き換えマップルーチンを変更
		□参照元がFixscreenなのが冗長すぎる。frame320の活用を検討
	■六角形タイルパターンは、細胞分割(borocell.pas)のハニカム配置で実現した

□細胞分割(ボロノイ)を再検討 (upatgen → s\borocell.pas)
	■膜より単純距離グラデーション・モード
		→ 無理があったので、「核より単純距離グラデーション・モード」を実装
	■画面をスキャンして、配置配列に入れるモード(お絵かきエフェクト？)
		□隙間無く配置を構成するために、スキャン範囲の拡大が必要
	■配置間隔を指定してハニカム配置
		→ 六角形の隙間なし並べは難しいので、六角形配置にした
		□もう一段個数を増やすか、段数を選択可能にする
		→ 六角形配置,平面配置とウロコ平面を選べるようにした
		ウロコ平面は「[D] 核 draw」で描画
			□「[D] 核 draw」の半径を選択可能にする
			□描画方式も選択可能にする (通常、比較明、平均)
			□描画順序のx,yを切り替えれるようにする
		□回転のサポート(アニメ対応でも必要？)
		■配置間隔によっては、配置個数が dottotal を超えるチェックが無かった
		□外円を設定可能にする。外円からの距離も最短距離比較の対象にする
	□シームレス・パターンになるようなランダム配置間隔
	□核二等分線より単純距離グラデーション・モード(ドロネー三角形分割)
		→ 実装をあきらめた。替わりに「膜より一定距離で maxcolor->0」を実装
	□アニメ対応	核回転, 核単振動
	□アニメ対応	ランダムウォーク
		要素の総和が0となる配列x,yをn個用意。乱数で要素をシャッフル
		  カウント数 mod (n+1) で、適用する細胞を選ぶ
		    → 挙動に規則性が出るので、255個のバイト型配列を用意したほうが？
	■dotarray構造体のうち、距離を保存する len は必要なのか？xdot,ydot もsingle可？
		→ xdot,ydot,id1,id2 とし、すべて integer にした
		C=a^2+b^2 で、Cがrealでもa,bがintegerの場合→ Cにintegerが格納される
			integerのmaxは32kのため、これより大きいと負数が格納される
			→ a+0.001 として、Cにrealで格納されるようにした
			この変更で、dots[0] の領域が0になるバグが解消された
	■dotarray構造体 id1 に、参照画面の9pixelの平均値を格納。
		x,y座標の最近傍の値で、pset。→ クリスタルフィルタ？
	□アニメ対応	円の拡縮振動(円の中には配置しない。円の拡大に合わせて移動)
	□アニメ対応は、モードによって選択肢が複雑になる
	→ スキャンモードと、それ以外ではメニューを出してイチイチ選択させる

□接触充填球 setuen.pas の見直し
	□データ配列をシンプルに。アニメ対応の配列を無くして、カウント数の mod で分岐
	□接触充填球モードでも配列に格納して、点pset。→ スキャンして細胞分割


○UFRACTAL
□フラクタル・ノイズの実装 gfxfx2.zip の plazuma.pas を参考にする

□現状の plazuma.pas(中点変位法によるランダム・フラクタル) の見直し
	静止画モード	新規に適用, 画面に適用, 画面の0部分に適用
			fix0を変換行列とみなして、画面1を変換
	動画モード	フレーム画面に適用, フレーム画面の0部分に適用
			fix0を変換行列とみなして、画面1を変換
			画面分割サイズに応じてスクロール

□放電ラインの実装。PSTに組み込むのをやめ、UFRACTALのカテゴリに
	AfterEffect での稲妻パラメータ
		http://aep-effects.com/category1/category27/entry46.html
	■中点変位法法による再帰分割アルゴリズム
	■arctan関数では、-π/2〜π/2までなので、場合わけが複雑
	https://detail.chiebukuro.yahoo.co.jp:443/qa/question_detail/q1423819324
		→ θ = 2*arctan(b/(√(a^2+b^2) + a)) を使う
	□中点からの乱数での変位量、再帰レベルを入力可能にする
	□筆を四角として描画。大きさを変更可能にする
	□ランダムに分岐枝を発生させる頻度と再帰レベルを設定可能にする
	□ラインの始点・終点の組み合わせをファイルから読み込んで実行
	□ラインの始点・終点の組み合わせのプリセットメニュー
		□多角形を構成(擬似的に円環電光)
		□内半径(または原点) → 外半径: それぞれの円周上の点を結ぶ
		□直線A → 直線B: それぞれの直線上の点を結ぶ
	■アニメ対応: 単純繰り返し(固定点で実行の繰り返し)
	□アニメ対応: 単純移動(線分割点を移動しながら実行の繰り返し)
	□アニメ対応: ピンポン移動(それぞれ移動方向の初期値はランダムに決定)


○UFILTER
■3X3 畳み込み演算によるフィルタ mat2d.pas の再検討
	→ 各項の総和を求めて、各項を総和で割り算したものを足し算するようにした
	■オペレータそれぞれを、変更に合わせて修正
	■機能メニューで、オペレータを選べるようにする
	■内側へのボカシ  pointカラーを逆転して処理
		→ □あまり効果がみられない

□5X5 のボカシフィルタ。(diffuser.pas の 7X7 で十分？)
□ボカシをグラディーションに変換するグラディエント・パスもどき
	トーンカーブで対応：	／ → ＼
				／ → ／＼
	数本の色をmaxcolorで残してから、3X3ボカシの適用

■レリーフ(dif.pas)を削除(3X3 畳み込み演算フィルタで十分？)	
	■修正して、gradater.pas or dither.pas に再組み込みを検討
	→ dither.pas に組み込んだ
■砂目(sand.pas)を削除
	指定した座標の色を乱数で +1 or -1 するルーチンにバグを発見
	■バグを修正して、gradater.pas or dither.pas に再組み込みを検討
		□乱数での偏りで、-1側が少ない
	→ dither.pas に組み込んだ
■dither.pas を変更。それぞれの処理をモードで選択するようにする
	■それぞれの処理の参照を画像1にするよう変更

□gradater.pas を変更。メニューによって処理を選択、8方向はテンキーに合わせる
	□グラデ範囲の幅を指定可にして、その両側を 0,maxcolor に塗り分ける
		□ワイプアニメ用マスクとして使えるように幅移動をアニメ化

■edge.pas を変更。8方向はテンキーに合わせる

■iir.pas を変更。8方向はテンキーに合わせる




□正三角形の線分120度2回転によるタイリング



○PICOP
■picop と paint で、push0, pop0 のキーコマンドを合わせる
	picop:  [8] push 0      [9] pop 0
■カットブラシの保存フレーム ←→ 画面
	   brush→ screen0		emstoscrn((2+1)*animofset+3)
	(  pop0 → screen0		emstoscrn((2+1)*animofset+1)  )
□[B] Brush OP を追加して、ブラシ処理
	□paint と picop の連絡のために、グローバル変数を割り当て
	□カットブラシを画面中央に。元の位置に復帰
	□ブラシ加工後の大きさに合わせて、ブラシ変数を変更
■[M] effect Moveに追加。座標に応じてオーバーレイ、アンダーレイの切り替え
	O : Overlay        U : Underlay
	H : O/U 水平change V : O/U 垂直change    (鎖の表現が可能になる)
	■裏画面(mask)に応じてオーバーレイ、アンダーレイの切り替え
		B : O/U 裏画面mask
	■emsop の[M] effect Move anim も合わせて変更
■[M] effect Moveを変更。screen合成の処理を変更
	(15-c1)*(15-c2)/15 → 15-(15-c1)*(15-c2)/15
	■emsop の[M] effect Move anim も合わせて変更
	■SYSBRUSH.INC の mxscrn も合わせて変更
■[M] effect Moveを変更。cross xline, cross yline, cross stetch を削除？
	→ overlay+平均 よりも、合成結果が有意な場合があるので、not0 to に変更して残す
	■emsop の[M] effect Move anim も合わせて変更
□[M] effect Moveに追加。トーンの配分による合成
	□emsop の[M] effect Move anim も合わせて変更
■[M] effect Moveに追加。マスク作成
	■emsop の[M] effect Move anim も合わせて変更
	■UFILTER.PAS より マスク作成 を削除
	□あらたに masK OP を追加して、境界のボカシ等を追加
■[M] effect Moveに追加。-90°回転(トリム)
	■emsop の[M] effect Move anim も合わせて変更
■テンポラリ画像ファイルの入出力
	to dark, to light は、削除(copy&effect の dec not0, inc not0 で代用)
■「パレットを明度順に並び替えて、色ソート」が不自然な結果になる
	→ AGRAPH2.PAS のルーチン変更。R,G,B の錯体反応による重み付けをやめる
■[G] グラフィック画面表示 で、カーソルをoffにする
■color change 系の一部を、[X] eX Color OP としてまとめる
	■トーンカーブ処理を追加。背景の0に影響を与えずに処理
		■UFILTER.PAS より トーンカーブ を削除
	■Amiga DigiView の色配置を明度順に変更するルーチンを復活した
	□TIC-80 の色配置を変換 デフォルト ←→ 明度順



○EMSOP
■アニメ再生で、裏画面を破壊しない方法(スムース表示を諦める？)を検討
	→ 裏画面(screenad(access,display))を fixscreen しておき、処理後 undo で復帰
	■再生スピードが速すぎるので、適切なウェイトを入れる
		→ delay(30)
■メニュー配置を picop と合わせる
	■emsop に compress 1/n を追加
	□UTRANS.PAS から compress 1/n を削除
	□UTRANS.PAS から Comp 対称 1/4 を削除
		□emsop, picop の compress 1/n に Comp 対称 1/4 を追加
	■emsop から、 dissolve copy を削除(wipe -> dissole ルーチンと重複)
■emsop に slit wipe をインクルードして、Wipe OP。 UWIPE.TPU を削除
	■UFILTER.PAS より スリット加工 を削除
■[M] effect Move x-flip が不具合。ソース整形時、picop に合わせたためにエンバグ
	→ scroll, trim scroll, x-flip, y-flip を修正した 






ease：インとアウトをなめらかに
linear：一定
ease-in：ゆっくりイン
ease-out：ゆっくりアウト
ease-in-out：ゆっくりインしてゆっくりアウト
cubic-bezier(値, 値, 値, 値)：独自に設定

線型  |放物線| Trail|

